## Exercise 4: Release Management

**Objective:** Manage Helm releases through installation, upgrades, rollbacks, and uninstallation. By the end of this exercise, you will understand how Helm tracks release history, how to safely apply changes, and how to recover from failed or undesired deployments.

## Background

When you install a Helm chart, Helm creates a **release**, which represents a specific instance of a chart deployed into a Kubernetes cluster. Helm stores release metadata in the cluster and maintains a history of revisions, allowing you to inspect changes, upgrade deployments, and roll back to previous states.

Release management is one of Helm’s most powerful features and is essential for production operations, controlled rollouts, and GitOps workflows.

## Steps

### 1. Inspect existing releases

List all Helm releases in the `helm-demo` namespace:

```bash
helm list -n helm-demo
```

You should see the release you installed in the previous exercise (for example, `demo-app`).

View the release history:

```bash
helm history demo-app -n helm-demo
```

Each revision corresponds to an install or upgrade operation.

### 2. Inspect rendered manifests

View the Kubernetes manifests generated by Helm for the current release:

```bash
helm get manifest demo-app -n helm-demo
```

This output shows the fully rendered YAML that was applied to the cluster. Comparing this output across revisions helps diagnose configuration issues.

You can also view the values used for the release:

```bash
helm get values demo-app -n helm-demo
```

Add `--all` to include default values:

```bash
helm get values demo-app -n helm-demo --all
```

### 3. Perform an upgrade

Modify a value in `values.yaml` or override a value at upgrade time. For example, scale the application by increasing the replica count:

```bash
helm upgrade demo-app demo-repo/demo-app \
  --set replicaCount=3 \
  -n helm-demo
```

Verify the change:

```bash
kubectl get deployment demo-app -n helm-demo
kubectl get pods -n helm-demo
```

Confirm that the desired number of replicas is running.

### 4. Simulate a faulty upgrade

Perform an upgrade that introduces an error, such as an invalid image tag:

```bash
helm upgrade demo-app demo-repo/demo-app \
  --set image.tag=nonexistent \
  -n helm-demo
```

Check the deployment status:

```bash
kubectl get pods -n helm-demo
```

Pods may fail with `ImagePullBackOff`. Inspect the release history again:

```bash
helm history demo-app -n helm-demo
```

Note the failed or problematic revision.

### 5. Roll back to a previous revision

Identify the last known good revision from the history output (for example, revision `2`). Roll back the release:

```bash
helm rollback demo-app 2 -n helm-demo
```

Verify recovery:

```bash
kubectl get pods -n helm-demo
helm history demo-app -n helm-demo
```

The application should return to a healthy state, and the rollback itself becomes a new revision.

### 6. Use dry-run and diff (best practice)

Before applying changes in real environments, always preview upgrades:

```bash
helm upgrade demo-app demo-repo/demo-app \
  --set replicaCount=2 \
  -n helm-demo \
  --dry-run --debug
```

This renders templates and validates values without applying changes.

If you have the Helm diff plugin installed, you can also inspect changes:

```bash
helm diff upgrade demo-app demo-repo/demo-app -n helm-demo
```

### 7. Uninstall a release

When a release is no longer needed, remove it:

```bash
helm uninstall demo-app -n helm-demo
```

Verify cleanup:

```bash
helm list -n helm-demo
kubectl get all -n helm-demo
```

All Helm-managed resources should be removed.

## Verification

* Helm lists and tracks release history correctly
* Upgrades modify running workloads as expected
* Failed upgrades can be rolled back safely
* Rollbacks restore a previous stable state
* Uninstall removes all Helm-managed resources

## Common Issues

### Rollback does not fix the issue

If a rollback does not restore functionality:

* Verify the revision number is correct
* Inspect the rendered manifests for both revisions
* Check whether external resources (PVCs, Secrets) are affecting behavior

### Helm reports success but application fails

Helm validates template rendering, not application health. Always verify pod status and logs after upgrades:

```bash
kubectl describe pod <pod-name> -n helm-demo
kubectl logs <pod-name> -n helm-demo
```

### Orphaned resources after uninstall

Helm only removes resources defined in the chart. Resources created manually or outside the chart must be cleaned up separately.

### Conflicting manual changes

Avoid manually editing Kubernetes resources managed by Helm. Manual changes may be overwritten by upgrades or cause unexpected behavior during rollbacks.

## Next Steps

You now understand how to manage Helm releases throughout their lifecycle, including upgrades, rollbacks, and safe change validation. These skills are critical before introducing automation.

In the next phase, you will integrate Helm with **GitOps workflows** using tools like ArgoCD to automate deployments and continuously reconcile cluster state with Git repositories.

Continue to [Phase 4 – GitOps and Continuous Delivery](../phase-4-gitops/README.md).
